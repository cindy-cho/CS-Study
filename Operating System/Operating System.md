Operating System
=============

프로세스 :: 스레드
-----
* 프로그램 : 어떤 작업을 위해 실행할 수 있는 파일

* 프로세스
    * 개념
        * 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
            * 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
            * 운영체제로부터 시스템 자원을 할당받는 작업 단위
            * 실행된 프로그램
        * 할당받는 시스템 자원 : CPU 시간, 주소 공간, 메모리 영역(Code, Data, Stack, Heap)
    * 특징
        * 각각 독립된 메모리 영역을 할당받는다
        * 기본적으로 프로세스당 최소 1개의 스레드 (메인 스레드) 를 가진다
        * 각 프로세스는 별도의 주소공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다
        * 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간 통신 (IPC : Inter-Process-Communication)을 사용해야 한다. (파이프, 파일, 소켓 등을 이용)

* 스레드
    * 개념
        * 프로세스 내에서 실행되는 여러 흐름의 단위
        * 프로세스의 특정한 수행 경로
        * 프로세스가 할당받은 자원을 이용하는 실행의 단위
    * 특징
        * 스레드는 프로세스 내에서 Stack, Register 개별 할당 받고 Code, Data, Heap 영역은 공유
        * 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 변경 결과를 즉시 볼 수 있다
    * 자바 스레드
        * JVM이 운영체제의 역할을 한다
        * 자바에는 프로세스가 존재하지 않고 스레드만 존재
        * 자바 스레드는 JVM에 의해 스케쥴 되는 실행 단위 코드 블록
        * 자바에서 스레드 스케쥴링은 전적으로 JVM에 의해 이루어진다

멀티 프로세스 대신 멀티 스레드를 사용하는 이유
-----
* 프로그램을 여러개 돌리는 것 보다 하나의 프로그램 안에서 여러 작업을 해결 한다

* 자원의 효율성 증대
    * 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다
        * 프로세스 간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화 되기 떄문에 오버헤드가 크다
    * 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고받은 것이 간단해지고 시스템 자원 소모가 줄어든다

* 처리 비용 감소 및 응답 시간 단축
    * 프로세스간 통신인 IPC 보다 스레드 간의 통신 비용이 적다
        * 스레드는 Stack을 제외한 다른 자원 공간을 공유하기 때문
    * 프로세스간 Context Switch 보다 스레드간 Context Switch 비용이 더 작다

* 신경 써야 할 점
    * 동기화 문제
    * 스레드 간의 자원 공유는 전역 변수 (Data Segment)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다

Thread-Safe
-----
* 개념
    * 멀티 스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작 하도록 한다

* 구현 방법
    * 공유 자원에 접근하는 Critical Section을 동기화 기법으로 제어
    * Mutex, Semaphore

* Reentrant (재진입성)
    * 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다는 의미
    * 이를 만족하기 위해서는 해당 서브루틴에서는 공유자원을 사용하지 않으면 된다
    * Reentrant하다면 Thread-Safe하다. (역은 성립하지 않는다)

동기화 객체의 종류
-----
* 종류
    * 실행 순서의 동기화
        * 스레드의 실행 순서를 정의하고, 이 순서에 반드시 따르도록 한다
    * 메모리 접근의 동기화
        * 메모리 접근에 있어서 동시 접근을 막는다

* 동기화 기법
    * 유저 모드 동기화
        * 커널 코드가 실행되지 않는 동기화 기법
        * 성능상 이점, 기능상 제한
            * 크리티컬 섹션 기반 동기화, 인터락 함수 기반 동기화
    * 커널 모드 동기화
        * 커널에서 제공하는 동기화 기능 활용
            * 커널 모드로의 변경이 필요 -> 성능 저하
            * 다양한 기능 활용 가능
            * 뮤텍스 기반 동기화, 세마포어 기반 동기화, 이벤트 기반 동기화

뮤텍스 :: 세마포어
-----
* 뮤텍스
    * 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 것
    * 크리티컬 섹션을 가진 스레드의 Running Time이 겹치치 않도록 단독으로 실행하게 한다
    * 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 Synchronized 또는 lock을 사용
        * 뮤텍스 객체를 동시에 여러개의 스레드가 사용할 수 없다

* 세마포어
    * 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
    * 리소스 상태를 나타내는 간단한 플래그로 생각
        * 운영체제 또는 커널의 한 지정된 저장장치 내의 값
        * 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용
        * 유닉스 시스템에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화 시키는 기술
        * 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자 접근 가능
        * 각 프로세스가 세마포어 값을 확인, 변경 가능

* 뮤텍스와 세마포어의 차이
    * 동기화 대상의 개수
        * 뮤텍스 : 한 개
        * 세마포어 : 한 개 이상
    * 뮤텍스는 세마포어가 될 수 없지만, 세마포어는 뮤텍스가 될 수 있다
    * 뮤텍스는 소유 가능한 반면, 세마포어는 소유할 수 없다
    * 뮤텍스는 소유하고 있는 스레드가 해제할 수 있다. 세마포어는 소유하지 않는 스레드도 해제할 수 있다
    * 뮤텍스는 프로세스 범위를 가지며 프로세스 종료시 Clean up 된다. 세마포어는 시스템 범위에 걸쳐있고 파일 형태로 존재


스케쥴러
-----

동기 :: 비동기
-----
* 동기
    * 어떤 작업을 요청했을 떄 그 작업이 종료될 때 까지 기다린 후 다음 작업을 수행한다
    * 데이터를 주고받는 순서가 중요할 때 사용
    * 요청한 작업만 처리하면 되기 때문에 전체적인 수행속도는 빠를 수 있다
    * 한 작업에 대한 시간이 길어질 경우, 전체 응답이 지연될 수 있다

* 비동기
    * 어떤 작업을 요청했을 떄 그 작업이 종료될 때 까지 기다리지 않고 다음 작업을 수행한다
    * 요청 순서에 상관없이 다수의 작업을 처리할 수 있다
    * 작업이 끝날 때 따로 이벤트를 감지하고 결과를 받아 그에 따른 추가작업을 해야하기 때문에 비교적 느릴 수 있다
    * I/O 작업이 잦고, 빠른 응답속도를 요구하는 프로그램에 적합

프로세스 동기화
-----

메모리 관리 전략
-----

가상 메모리
-----

캐시의 지역성
-----

데드락
-----
* 개념
    * 첫번째 스레드는 두번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두번째 스레드 역시 첫번째 스레드가 들고있는 객체의 락이 풀리기를 기다리는 상황
    * 모든 스레드가 락이 풀리기를 기다리고 있기 때문에 무한 대기 상태에 빠지게 된다

* 4가지 조건
    1. 상호 배제 (Mutual Exclusion)
        * 한 번에 한 프로세스만 공유 자원을 사용할 수 있다
        * 공유 자원에 대한 접근 권한이 제한된다
    2. 점유 대기 (Hold and Wait)
        * 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다
    3. 비선점 (Preemption)
        * 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다
    4. 순환 대기 (Circular Wait)
        * 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다

* 방지하기 위한 조건
    * 위의 4가지 조건 중 하나를 제거
    * 공유 자원 중 많읕 경우에 한번에 한 프로세스만 사용할 수 있기 때문에, 1번 조건은 제거하기 어렵다
    * 대부분은 4번 조건을 막는데 초점을 맞춘다

사용자 수준 스레드 :: 커널 수준 스레드
-----

외부 단편화 :: 내부 단편화
-----

Context Switching
-----
* 개념
    * 현재 진행하고 있는 Task(프로세스, 스레드)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정

* 동작 과정
    1. 현재 실행하고 있는 Task의 PCB(Process Control Block) 정보 저장
    2. 다음 실행할 Task의 PCB 정보를 읽어 레지스터에 적재하고 수행


Swapping
-----

